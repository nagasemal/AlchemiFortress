#include "pch.h"
#include "MissionManager.h"

#include "Scenes/PlayScene/AlchemicalMachine/AlchemicalMachineManager.h"
#include "Scenes/PlayScene/Enemy/EnemyManager.h"
#include "Scenes/PlayScene/UI/Number.h"

#include "Scenes/SelectScene/MissionRender.h"

#include "NecromaLib/Singleton/ShareJsonData.h"
#include "NecromaLib/Singleton/DeltaTime.h"

MissionManager::MissionManager():
	m_machineCondition(),
	m_enemyCondition(),
	m_timeCondition(),
	m_allClearFlag(),
	m_missionNum(),
	m_missionSituation(),
	m_timer(),
	m_failureFlag()
{
}

MissionManager::~MissionManager()
{
}

void MissionManager::Initialize()
{

	auto pSJD = &ShareJsonData::GetInstance();

	// 取得した情報をコピーする
	m_machineCondition = pSJD->GetStageData().condition_Machine;
	m_enemyCondition   = pSJD->GetStageData().condition_Enemy;
	m_timeCondition    = pSJD->GetStageData().condition_Time;

	// スタンダードならばTrueにする
	bool timeMission = m_timeCondition[0].condition == "Standerd";

	m_missionNum = (int)m_machineCondition.size() +
				   (int)m_enemyCondition.size() + 
				   (int)timeMission;

	m_missionSituation = 0;

	m_allClearFlag = false;

	m_timeRender = std::make_unique<Number>(SimpleMath::Vector2{220.0f,220.0f}, SimpleMath::Vector2{1.0f,1.0f});

	m_missionRender = std::make_unique<MissionRender>(SimpleMath::Vector2{ 100.0f,300.0f }, SimpleMath::Vector2{ 1.0f,1.0f });

}

void MissionManager::Update(AlchemicalMachineManager* alchemicalManager, EnemyManager* enemyManager)
{
	auto pDeltaT = &DeltaTime::GetInstance();

	m_timer += pDeltaT->GetDeltaTime();

	// None以外ならば通す マシンが設置された際の処理
	if (alchemicalManager->SpawnMachineNotification() != MACHINE_TYPE::NONE)
	{
		MachineMission(alchemicalManager);
	}

	// Enemyが倒された際に通す
	if (enemyManager->GetKnokDownEnemyType() != ENEMY_TYPE::ENMEY_NONE)
	{
		EnemyMission(enemyManager);
	}

	// 時間制限の処理
	if (m_timeCondition.size() > 0)
	{
		TimerMission();
	}
}

void MissionManager::Render()
{

	ShareData& pSD = ShareData::GetInstance();

	// 時間計測
	m_timeRender->SetNumber((int)m_timer);
	m_timeRender->Render();


	// ミッション内容の描画
	pSD.GetSpriteBatch()->Begin(SpriteSortMode_Deferred, pSD.GetCommonStates()->NonPremultiplied());
	m_missionRender->Render_MachineMission(m_machineCondition);
	m_missionRender->Render_EnemyMission(m_enemyCondition);
	m_missionRender->Render_TimerMission(m_timeCondition);
	m_missionRender->LineReset();
	pSD.GetSpriteBatch()->End();


}

bool MissionManager::MissionComplete()
{
	return m_missionNum <= m_missionSituation;
}

bool MissionManager::MissionmFailure()
{
	return m_failureFlag;
}

int MissionManager::GetStartTimer()
{
	return m_timeCondition[0].progress;
}

void MissionManager::MachineMission(AlchemicalMachineManager* alchemicalManager)
{
	// 対応する条件をTrueにする
	for (int i = 0; i < m_machineCondition.size(); i++)
	{
		// ミッションの内容と同じならば処理を通す 既にミッションが済んでいる場合は飛ばす
		if (Json::ChangeMachine(m_machineCondition[i].condition) ==
			alchemicalManager->SpawnMachineNotification() &&
			m_machineCondition[i].progress < m_machineCondition[i].value)
		{
			m_machineCondition[i].progress++;

			// 攻略完了
			if (m_machineCondition[i].progress >= m_machineCondition[i].value)
			{
				m_missionSituation++;
			}
		}
	}
}

void MissionManager::EnemyMission(EnemyManager* enemyManager)
{

	// 対応する条件をTrueにする
	for (int i = 0; i < m_enemyCondition.size(); i++)
	{
		// ミッションの内容と同じならば処理を通す 既にミッションが済んでいる場合は飛ばす
		if (Json::ChangeEnemy(m_enemyCondition[i].condition) ==
			enemyManager->GetKnokDownEnemyType() &&
			m_enemyCondition[i].progress < m_enemyCondition[i].value)
		{
			// 同一フレーム内に複数対敵がやられたとしても対応可能にする
			m_enemyCondition[i].progress += enemyManager->GetKnokDownEnemyFlag();

			// 攻略完了
			if (m_enemyCondition[i].progress >= m_enemyCondition[i].value)
			{
				m_missionSituation++;
			}
		}
	}

}

void MissionManager::TimerMission()
{

	// 生き残れば勝利系タイマー
	if (m_timeCondition[0].progress < m_timeCondition[0].value)
	{
		// 毎秒進行度を上げる
		m_timeCondition[0].progress = (int)m_timer;

		if (m_timeCondition[0].progress >= m_timeCondition[0].value)
		{

			if (m_timeCondition[0].condition == "Standerd") m_missionSituation++;
			if (m_timeCondition[0].condition == "Limit") m_failureFlag = true;
			
		}
	}
}
